#!/usr/bin/env python3
"""
apply_fixes.py - Applies code fixes suggested by Claude AI

This script:
1. Reads the fixes from the Claude AI response
2. Parses each fix to identify file paths and code changes
3. Applies the changes to the appropriate files
4. Validates the changes to ensure they don't break the code
"""

import json
import os
import re
import subprocess
import sys
from pathlib import Path

# Maximum number of fixes to apply per file to avoid large-scale changes
MAX_FIXES_PER_FILE = 10

# Maximum percentage of file that can be changed (to avoid destructive changes)
MAX_CHANGE_PERCENTAGE = 30

def parse_fixes_file():
    """Parse the fixes file generated by Claude AI."""
    try:
        with open('claude_fixes.json', 'r', encoding='utf-8') as f:
            data = json.load(f)
            return data.get('fixes', [])
    except FileNotFoundError:
        print("Warning: claude_fixes.json file not found")
        return []
    except json.JSONDecodeError:
        print("Error: claude_fixes.json is not valid JSON")
        return []
    except Exception as e:
        print(f"Error reading fixes file: {e}")
        return []

def parse_fix_block(fix_text):
    """Parse a single fix block."""
    lines = fix_text.strip().split('\n')
    
    fix_info = {
        'file': None,
        'original': [],
        'fixed': [],
        'explanation': [],
        'current_section': None
    }
    
    for line in lines:
        # File path is specified with "file: path/to/file.rs"
        if line.startswith('file:'):
            fix_info['file'] = line[5:].strip()
        # Start of original code block
        elif line == 'original: |':
            fix_info['current_section'] = 'original'
        # Start of fixed code block
        elif line == 'fixed: |':
            fix_info['current_section'] = 'fixed'
        # Start of explanation block
        elif line == 'explanation: |':
            fix_info['current_section'] = 'explanation'
        # Separator between sections
        elif line == '---':
            fix_info['current_section'] = None
        # Content for the current section
        elif fix_info['current_section']:
            # Remove the leading two spaces if they exist (YAML block scalar indentation)
            if line.startswith('  '):
                line = line[2:]
            fix_info[fix_info['current_section']].append(line)
    
    # Join the content of each section into a single string
    for section in ['original', 'fixed', 'explanation']:
        fix_info[section] = '\n'.join(fix_info[section])
    
    # Clean up
    del fix_info['current_section']
    
    return fix_info

def validate_fix(fix):
    """Validate that a fix has all required components."""
    required_fields = ['file', 'original', 'fixed']
    for field in required_fields:
        if not fix.get(field):
            return False
    
    # Ensure file exists
    if not os.path.isfile(fix['file']):
        print(f"Warning: File {fix['file']} does not exist")
        return False
    
    return True

def apply_fix_to_file(fix, applied_fixes, dry_run=False):
    """Apply a single fix to a file."""
    if not validate_fix(fix):
        return False
    
    file_path = fix['file']
    original = fix['original']
    fixed = fix['fixed']
    
    # Check if we've already applied the maximum number of fixes to this file
    if file_path in applied_fixes and applied_fixes[file_path] >= MAX_FIXES_PER_FILE:
        print(f"Skipping fix for {file_path}: maximum number of fixes ({MAX_FIXES_PER_FILE}) already applied")
        return False
    
    # Read file content
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")
        return False
    
    # Calculate change percentage
    def calculate_change_percentage(old_text, new_text):
        import difflib
        diff = difflib.unified_diff(
            old_text.splitlines(keepends=True),
            new_text.splitlines(keepends=True)
        )
        changes = sum(1 for line in diff if line.startswith('+') or line.startswith('-'))
        total_lines = len(old_text.splitlines())
        if total_lines == 0:
            return 100
        return (changes / total_lines) * 100 / 2  # Divide by 2 as each change counts twice (+ and -)
    
    # Check if the original code exists in the file
    if original not in content:
        # Try normalizing whitespace to fix common matching issues
        normalized_original = re.sub(r'\s+', ' ', original.strip())
        normalized_content = re.sub(r'\s+', ' ', content.strip())
        
        if normalized_original not in normalized_content:
            print(f"Warning: Original code not found in {file_path}")
            print("Original (first 100 chars):", original[:100])
            return False
        
        # If we match after normalization, we need a different approach
        # Use a regex replacement with flexible whitespace
        pattern = re.escape(normalized_original).replace('\\ ', r'\s+')
        updated_content = re.sub(pattern, fixed, normalized_content)
        
        # Change percentage check
        change_percent = calculate_change_percentage(normalized_content, updated_content)
        if change_percent > MAX_CHANGE_PERCENTAGE:
            print(f"Warning: Change too large ({change_percent:.1f}%) for {file_path}, skipping")
            return False
    else:
        # Simple replacement
        updated_content = content.replace(original, fixed)
        
        # Change percentage check
        change_percent = calculate_change_percentage(content, updated_content)
        if change_percent > MAX_CHANGE_PERCENTAGE:
            print(f"Warning: Change too large ({change_percent:.1f}%) for {file_path}, skipping")
            return False
    
    # If the content didn't change, no need to continue
    if content == updated_content:
        print(f"No changes needed for {file_path}")
        return False
    
    if dry_run:
        print(f"Would update {file_path} (change: {change_percent:.1f}%)")
        return True
    
    # Apply the changes
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(updated_content)
        
        # Update applied fixes count
        if file_path not in applied_fixes:
            applied_fixes[file_path] = 1
        else:
            applied_fixes[file_path] += 1
        
        print(f"Updated {file_path} (applied fix {applied_fixes[file_path]}/{MAX_FIXES_PER_FILE})")
        return True
    except Exception as e:
        print(f"Error writing to file {file_path}: {e}")
        return False

def validate_changes(changed_files):
    """Validate that the changes don't break the code."""
    print("Validating changes...")
    
    # Run cargo check to ensure the code still compiles
    result = subprocess.run(['cargo', 'check'], 
                            capture_output=True, 
                            text=True)
    
    if result.returncode != 0:
        print("Error: Changes caused compilation errors:")
        print(result.stderr)
        
        # Revert the changes
        for file_path in changed_files:
            subprocess.run(['git', 'checkout', '--', file_path])
        
        print("All changes have been reverted")
        return False
    
    print("Changes validated successfully")
    return True

def main():
    # Parse the fixes
    raw_fixes = parse_fixes_file()
    
    if not raw_fixes:
        print("No fixes to apply")
        return
    
    print(f"Found {len(raw_fixes)} potential fixes to apply")
    
    # Parse each fix block
    fixes = []
    for fix_text in raw_fixes:
        try:
            fix = parse_fix_block(fix_text)
            fixes.append(fix)
        except Exception as e:
            print(f"Error parsing fix: {e}")
    
    print(f"Successfully parsed {len(fixes)} fixes")
    
    # Apply the fixes
    applied_fixes = {}  # Track how many fixes we've applied to each file
    changed_files = set()  # Track which files we've changed
    
    # First do a dry run to count how many files would change
    print("Performing dry run...")
    for fix in fixes:
        if apply_fix_to_file(fix, {}, dry_run=True):
            changed_files.add(fix['file'])
    
    print(f"Dry run complete. {len(changed_files)} files would be changed.")
    
    # Reset and apply for real
    changed_files = set()
    for fix in fixes:
        if apply_fix_to_file(fix, applied_fixes):
            changed_files.add(fix['file'])
    
    # Generate a summary of the changes
    print("\nSummary of Applied Fixes:")
    print(f"- Total fixes analyzed: {len(fixes)}")
    print(f"- Files modified: {len(changed_files)}")
    print(f"- Total changes applied: {sum(applied_fixes.values())}")
    
    if changed_files:
        print("\nModified files:")
        for file_path in sorted(changed_files):
            print(f"- {file_path}: {applied_fixes.get(file_path, 0)} fixes")
        
        # Validate the changes
        if not validate_changes(changed_files):
            sys.exit(1)
    else:
        print("No changes were applied")

if __name__ == "__main__":
    main()
